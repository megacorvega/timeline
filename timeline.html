<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>timeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cascadia+Code&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Gray-50 */
        }
        .dark body {
            background-color: #020617; /* Slate-950 */
        }
        .title-font {
            font-family: 'Cascadia Code', monospace;
        }
        .custom-checkbox {
            appearance: none;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
            flex-shrink: 0;
        }
        .dark .custom-checkbox {
            background-color: #374151;
            border-color: #4b5563;
        }
        .custom-checkbox:checked {
            background-color: #16a34a;
            border-color: #16a34a;
        }
        .custom-checkbox:checked::after {
            content: 'âœ”';
            position: absolute;
            color: white;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
        }
        /* Modal Datepicker Styles */
        .flatpickr-calendar {
            z-index: 1000 !important;
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }
        .chart-grid .domain { stroke: #cbd5e1; }
        .dark .chart-grid .domain { stroke: #475569; }
        .chart-grid .tick line { stroke: #e2e8f0; }
        .dark .chart-grid .tick line { stroke: #334155; }
        .chart-grid .tick text { fill: #64748b; font-size: 10px; }
        .dark .chart-grid .tick text { fill: #94a3b8; }
        .planned-line {
            stroke: #9ca3af;
            stroke-width: 2;
            stroke-dasharray: 4, 4;
        }
        .finish-line {
            stroke: #ef4444; /* Red-500 */
            stroke-width: 2;
        }
        .ghost-finish-line {
            stroke: #fca5a5; /* Red-300 */
            stroke-width: 1.5;
            stroke-dasharray: 2, 2;
        }
        .actual-line {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
        }
        .projected-line {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-dasharray: 5, 5;
        }
        .actual-point {
            r: 4;
        }
        .today-line {
            stroke: #3b82f6; /* Blue-500 */
            stroke-width: 1.5;
        }
        .phase-marker-circle {
            r: 10;
            fill: #3b82f6; /* Blue-500 */
            stroke: #fff;
            stroke-width: 2;
        }
        .dark .phase-marker-circle {
            stroke: #020617; /* Slate-950 */
        }
        .phase-marker-text {
            font-size: 10px;
            font-weight: bold;
            fill: #fff;
            text-anchor: middle;
            dominant-baseline: central;
        }
        .date-input-container {
            position: relative;
            display: flex;
            align-items: center;
        }
        .date-input {
            background-color: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.75rem;
            padding: 2px 28px 2px 6px; /* Added padding-right for icon */
            width: 100px;
            height: 28px; /* Set height */
        }
        .dark .date-input {
            background-color: #1e293b;
            border-color: #334155;
        }
        .date-input-icon-wrapper {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            padding: 0 6px;
            cursor: pointer;
            color: #6b7280;
        }
        .dark .date-input-icon-wrapper {
             color: #9ca3af;
        }
        /* Custom button for flatpickr */
        .flatpickr-today-button {
            background: #e5e7eb;
            color: #374151;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 600;
            border-radius: 4px;
        }
        .dark .flatpickr-today-button {
            background: #374151;
            color: #e5e7eb;
        }
        .chevron {
            transition: transform 0.2s;
        }
        .btn-sm {
            padding-left: 0.75rem;
            padding-right: 0.75rem;
            font-size: 0.75rem;
            line-height: 1rem;
            height: 28px;
            display: flex;
            align-items: center;
        }

        .dependency-candidate {
             cursor: pointer;
             border: 1px dashed #9ca3af;
        }
        .dependency-selected {
            outline: 2px solid #16a34a;
            background-color: rgba(22, 163, 74, 0.1);
        }
       .driven-by-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #3b82f6; /* Blue-500 */
            flex-shrink: 0;
            cursor: help;
        }
        .dependency-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .dependency-circle {
            width: 14px;
            height: 14px;
            background-color: #d1d5db; /* gray-300 */
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            border-radius: 50%;
            position: relative;
        }
        .dependency-circle span {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: #fff;
        }
        .dark .dependency-circle {
            background-color: #4b5563; /* gray-600 */
        }
        .phase-row > .item-main-row:hover .dependency-container .dependency-circle,
        .task-row > .item-main-row:hover .dependency-container .dependency-circle,
        .subtask-row:hover .dependency-container .dependency-circle {
            opacity: 1;
        }
        .is-dependent-source {
            background-color: #ef4444 !important; /* Red-500 */
            opacity: 1 !important;
        }
        .is-parent-source {
            background-color: #f59e0b !important; /* Amber-500 */
            opacity: 1 !important;
        }


        @media print {
            body {
                background-color: #fff;
            }
            header, .bg-white.dark\\:bg-slate-900:first-of-type, #import-btn, #export-btn, #pdf-btn, #theme-toggle, #dependency-btn-container, #dependency-tooltip, #fullscreen-modal {
                display: none !important;
            }
            .project-card {
                page-break-before: always;
                box-shadow: none;
                border: 1px solid #e2e8f0;
            }
            .project-card:first-of-type {
                page-break-before: auto;
            }
            .dark body {
                 background-color: #fff;
                 color: #000;
            }
             .dark .project-card, .dark .bg-gray-100, .dark .bg-gray-50 {
                background-color: #fff !important;
             }
             .dark .text-white {
                color: #000 !important;
             }
        }

        .dependency-tree-node {
            display: flex;
            flex-direction: column;
            align-items: start;
        }
        .dependency-tree-node .node-content {
            padding: 4px 8px;
            border-radius: 6px;
            background-color: #f3f4f6; /* gray-100 */
            border: 1px solid #e5e7eb; /* gray-200 */
            font-size: 12px;
            margin-bottom: 4px;
            transition: all 0.2s;
        }
        .dark .dependency-tree-node .node-content {
            background-color: #334155; /* slate-700 */
            border-color: #475569; /* slate-600 */
        }
        .dependency-tree-node .node-children {
            padding-left: 20px;
            position: relative;
        }
         .dependency-tree-node .node-children > .dependency-tree-node {
            margin-top: 4px;
         }
        .dependency-tree-node .node-children::before {
            content: '';
            position: absolute;
            left: 5px;
            top: -4px;
            bottom: 4px;
            width: 1px;
            background-color: #d1d5db; /* gray-300 */
        }
        .dark .dependency-tree-node .node-children::before {
            background-color: #475569; /* slate-600 */
        }
        .dependency-tree-node .node-children > .dependency-tree-node::before {
            content: '';
            position: absolute;
            left: -15px;
            top: 12px;
            width: 15px;
            height: 1px;
            background-color: #d1d5db; /* gray-300 */
        }
         .dark .dependency-tree-node .node-children > .dependency-tree-node::before {
             background-color: #475569; /* slate-600 */
         }
        .node-content.highlight {
            outline: 2px solid #3b82f6; /* blue-500 */
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
            font-weight: 600;
        }
        .node-type-label {
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            color: #9ca3af; /* gray-400 */
            margin-bottom: 4px;
        }

        .add-subtask-btn {
            display: none;
        }
        .task-row:hover .add-subtask-btn {
            display: flex;
        }

        #fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f8fafc;
            z-index: 1000;
            display: none;
            padding: 2rem;
            box-sizing: border-box;
        }
        .dark #fullscreen-modal {
            background-color: #020617;
        }
        #fullscreen-chart-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #close-fullscreen-btn {
            position: absolute;
            top: -1rem;
            right: -1rem;
            background: #e5e7eb;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dark #close-fullscreen-btn {
            background: #374151;
            color: #e5e7eb;
        }
        .chart-tooltip {
            position: absolute;
            visibility: hidden;
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            pointer-events: none;
            white-space: nowrap;
        }
        .dark .chart-tooltip {
            background: #1e293b;
            border-color: #334155;
        }
        .phase-label {
            background-color: #3b82f6;
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
            word-wrap: break-word;
            max-width: 100%;
            text-align: center;

        }
        .editable-text {
            cursor: pointer;
        }
    </style>
</head>
<body class="antialiased text-gray-900 dark:text-white">
    <div id="datepicker-backdrop" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50"></div>

    <div id="reason-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[1001] flex items-center justify-center p-4">
        <div class="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 id="reason-modal-title" class="text-lg font-bold mb-4">Reason for Change</h3>
            <p id="reason-modal-details" class="text-sm text-gray-600 dark:text-gray-400 mb-4"></p>
            <textarea id="reason-comment" class="w-full p-2 border rounded-md dark:bg-slate-700 dark:border-slate-600 focus:ring-2 focus:ring-blue-500 focus:outline-none" rows="3" placeholder="Please provide a brief reason..."></textarea>
            <div class="mt-4 flex justify-end gap-2">
                <button id="cancel-reason-btn" class="px-4 py-2 rounded-md bg-gray-200 dark:bg-gray-600 font-semibold text-sm">Cancel</button>
                <button id="save-reason-btn" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold text-sm">Save Change</button>
            </div>
        </div>
    </div>
    
    <div id="confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[1001] flex items-center justify-center p-4">
        <div class="bg-white dark:bg-slate-800 p-6 rounded-lg shadow-xl w-full max-w-sm">
            <h3 id="confirm-modal-title" class="text-lg font-bold mb-4">Confirm Action</h3>
            <p id="confirm-modal-text" class="text-sm text-gray-600 dark:text-gray-400 mb-6"></p>
            <div class="flex justify-end gap-2">
                <button id="cancel-confirm-btn" class="px-4 py-2 rounded-md bg-gray-200 dark:bg-gray-600 font-semibold text-sm">Cancel</button>
                <button id="confirm-action-btn" class="px-4 py-2 rounded-md bg-red-600 text-white font-semibold text-sm">Confirm</button>
            </div>
        </div>
    </div>

    <div id="dependency-banner" class="hidden sticky top-0 bg-blue-100 dark:bg-blue-900 border-b-2 border-blue-500 text-blue-800 dark:text-blue-200 text-center py-2 z-40">
        <p><b>Dependency Mode:</b> Click a dependent item to create the link. Press ESC to cancel.</p>
    </div>

    <div id="dependency-tooltip" class="hidden absolute z-[1002] p-3 bg-white dark:bg-slate-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-xl text-xs w-max max-w-xs"></div>

    <div id="fullscreen-modal">
        <div id="fullscreen-chart-container">
            <button id="close-fullscreen-btn">&times;</button>
        </div>
    </div>

    <div class="container mx-auto p-4 sm:p-5 max-w-6xl">

        <header class="mb-5 flex justify-between items-start">
            <div>
                <h1 class="text-2xl font-bold title-font">
                    <span class="text-gray-500 dark:text-gray-400">time</span><span class="text-black dark:text-white">line</span>
                </h1>
            </div>
            <div class="flex items-center gap-4">
                <button id="import-btn" class="px-3 py-1.5 text-xs font-semibold rounded-md bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">Import</button>
                <button id="export-btn" class="px-3 py-1.5 text-xs font-semibold rounded-md bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">Export</button>
                <button id="pdf-btn" class="px-3 py-1.5 text-xs font-semibold rounded-md bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">Print to PDF</button>
                <input type="file" id="import-file-input" class="hidden" accept=".json">
                <button id="theme-toggle" class="p-2 rounded-lg bg-gray-200 dark:bg-gray-700">
                    <svg id="theme-toggle-dark-icon" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                    <svg id="theme-toggle-light-icon" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
                </button>
            </div>
        </header>

        <div class="bg-white dark:bg-slate-900 p-3 rounded-xl shadow-md mb-5 border border-gray-200 dark:border-gray-800">
            <h2 class="text-lg font-semibold mb-2">Add a New Project</h2>
            <div class="flex flex-col sm:flex-row gap-2 items-center">
                <input type="text" id="new-project-name" placeholder="Enter new project name..." class="flex-grow w-full px-3 py-1.5 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm h-[28px]" onkeydown="if(event.key==='Enter') addProject()">
                <div class="date-input-container">
                    <input type="text" id="new-project-start-date" placeholder="Start Date" class="date-input" data-type="new-project-start" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                    <div class="date-input-icon-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg></div>
                </div>
                <div class="date-input-container">
                    <input type="text" id="new-project-end-date" placeholder="End Date" class="date-input" data-type="new-project-end" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                     <div class="date-input-icon-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg></div>
                </div>
                <button id="add-project-btn" class="w-full sm:w-auto bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-colors btn-sm">
                    Add
                </button>
            </div>
        </div>

        <div id="projects-container" class="space-y-6"></div>
        <div class="mt-6">
            <button id="toggle-deleted-log-btn" class="text-xs font-semibold text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 flex items-center gap-1 mb-2 hidden">
                <svg id="deleted-log-chevron" class="w-4 h-4 chevron -rotate-90" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
                Deleted Projects Log
            </button>
            <div id="deleted-projects-log-content" class="hidden"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script>
        // --- STATE & CONFIG ---
        let projects = [];
        let deletedProjectLogs = [];
        let sharedPicker = null;
        let currentPickerContext = null;
        let pendingDateChange = null;
        let pendingDeletion = null;
        let dependencyMode = false;
        let firstSelectedItem = null;
        let pendingClearDependencies = null;
        let deletedLogCollapsed = true;

        // --- DOM ELEMENTS ---
        const projectsContainer = document.getElementById('projects-container');
        const addProjectBtn = document.getElementById('add-project-btn');
        const newProjectNameInput = document.getElementById('new-project-name');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const darkIcon = document.getElementById('theme-toggle-dark-icon');
        const lightIcon = document.getElementById('theme-toggle-light-icon');
        const importBtn = document.getElementById('import-btn');
        const exportBtn = document.getElementById('export-btn');
        const pdfBtn = document.getElementById('pdf-btn');
        const importFileInput = document.getElementById('import-file-input');
        const datepickerBackdrop = document.getElementById('datepicker-backdrop');
        const reasonModal = document.getElementById('reason-modal');
        const reasonModalTitle = document.getElementById('reason-modal-title');
        const reasonModalDetails = document.getElementById('reason-modal-details');
        const reasonCommentTextarea = document.getElementById('reason-comment');
        const saveReasonBtn = document.getElementById('save-reason-btn');
        const cancelReasonBtn = document.getElementById('cancel-reason-btn');
        const dependencyBanner = document.getElementById('dependency-banner');
        const dependencyTooltip = document.getElementById('dependency-tooltip');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmModalTitle = document.getElementById('confirm-modal-title');
        const confirmModalText = document.getElementById('confirm-modal-text');
        const cancelConfirmBtn = document.getElementById('cancel-confirm-btn');
        const confirmActionBtn = document.getElementById('confirm-action-btn');
        const fullscreenModal = document.getElementById('fullscreen-modal');
        const closeFullscreenBtn = document.getElementById('close-fullscreen-btn');


        // --- DATA & UTILS ---
        function saveProjects() {
            localStorage.setItem('projectTimelineData', JSON.stringify(projects));
            localStorage.setItem('projectTimelineDeletedLogs', JSON.stringify(deletedProjectLogs));
        }
        function loadProjects() {
            const savedData = localStorage.getItem('projectTimelineData');
            let loadedProjects = [];
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    if (Array.isArray(parsedData)) {
                        loadedProjects = parsedData;
                    }
                } catch (error) { console.error("Error parsing projects from localStorage:", error); }
            }
            projects = loadedProjects;
            projects.forEach(project => {
                if (!project.originalStartDate) project.originalStartDate = project.startDate;
                if (!project.originalEndDate) project.originalEndDate = project.endDate;
                if (!project.phases) project.phases = [];
                project.phases.forEach(phase => { 
                    if(phase.collapsed === undefined) phase.collapsed = false; 
                    if(!phase.dependencies) phase.dependencies = [];
                    if(!phase.dependents) phase.dependents = [];
                    phase.tasks.forEach(task => {
                        if(task.collapsed === undefined) task.collapsed = false;
                        if(!task.dependencies) task.dependencies = [];
                        if(!task.dependents) task.dependents = [];
                        if(task.subtasks) {
                            task.subtasks.forEach(subtask => {
                                if(!subtask.dependencies) subtask.dependencies = [];
                                if(!subtask.dependents) subtask.dependents = [];
                            });
                        }
                    });
                });
                if (!project.logs) project.logs = [];
                if (project.collapsed === undefined) project.collapsed = false;
                if (typeof project.startDate !== 'string' || project.startDate.trim() === '') project.startDate = null;
                if (typeof project.endDate !== 'string' || project.endDate.trim() === '') project.endDate = null;
            });

            const savedDeletedLogs = localStorage.getItem('projectTimelineDeletedLogs');
            if (savedDeletedLogs) {
                try {
                    deletedProjectLogs = JSON.parse(savedDeletedLogs);
                } catch (error) {
                    console.error("Error parsing deleted project logs from localStorage:", error);
                    deletedProjectLogs = [];
                }
            }
        }
        const parseDate = d3.timeParse("%Y-%m-%d");
        const formatDate = d3.timeFormat("%m/%d/%y");
        const formatLogTimestamp = d3.timeFormat("%Y-%m-%d %H:%M");

        function sortByEndDate(a, b, dateKey = 'endDate') {
            const dateA = a[dateKey] ? parseDate(a[dateKey]) : null;
            const dateB = b[dateKey] ? parseDate(b[dateKey]) : null;
            if (dateA && dateB) return dateA - dateB;
            if (dateA) return -1;
            if (dateB) return 1;
            return 0;
        }

        function getBoundaryDate(items, type) {
            const dates = items.map(item => parseDate(type === 'latest' ? item.effectiveEndDate || item.endDate : item.effectiveStartDate || item.startDate)).filter(Boolean);
            if (dates.length === 0) return null;
            const boundary = type === 'latest' ? new Date(Math.max.apply(null, dates)) : new Date(Math.min.apply(null, dates));
            return boundary.toISOString().split('T')[0];
        }

        function calculateRollups() {
            projects.forEach(p => {
                p.phases.forEach(phase => {
                    phase.isDriven = false; // Reset driven flag
                    phase.tasks.forEach(task => {
                        task.isDriven = false; // Reset driven flag
                         if (task.subtasks) {
                            task.subtasks.forEach(st => st.isDriven = false);
                        }
                        const hasSubtasks = task.subtasks && task.subtasks.length > 0;
                        if (hasSubtasks) {
                            task.effectiveStartDate = getBoundaryDate(task.subtasks, 'earliest');
                            task.effectiveEndDate = getBoundaryDate(task.subtasks, 'latest');
                            const completedSubtasks = task.subtasks.filter(st => st.completed).length;
                            task.progress = task.subtasks.length > 0 ? (completedSubtasks / task.subtasks.length) * 100 : 0;
                            task.completed = task.progress === 100;
                        } else {
                            task.effectiveStartDate = task.startDate;
                            task.effectiveEndDate = task.endDate;
                            task.progress = task.completed ? 100 : 0;
                        }
                    });
                    
                    phase.effectiveStartDate = getBoundaryDate(phase.tasks, 'earliest');
                    phase.effectiveEndDate = getBoundaryDate(phase.tasks, 'latest');
                    const totalProgress = phase.tasks.reduce((sum, t) => sum + (t.progress || 0), 0);
                    phase.progress = phase.tasks.length > 0 ? totalProgress / phase.tasks.length : 0;
                    phase.completed = phase.progress === 100;
                });

                p.totalPhaseProgress = p.phases.reduce((sum, ph) => sum + (ph.progress || 0), 0);
                p.overallProgress = p.phases.length > 0 ? p.totalPhaseProgress / p.phases.length : 0;
            });
        }

        function resolveDependencies() {
            const allItems = new Map();
            projects.forEach(p => {
                p.phases.forEach(ph => {
                    allItems.set(ph.id, ph);
                    ph.tasks.forEach(t => {
                        allItems.set(t.id, t);
                        if (t.subtasks) {
                            t.subtasks.forEach(st => allItems.set(st.id, st));
                        }
                    });
                });
            });

            // Iterate multiple times to ensure all dependencies are resolved in order
            for (let i = 0; i < allItems.size; i++) {
                allItems.forEach(item => {
                    if (item.dependencies && item.dependencies.length > 0) {
                        let latestParentEndDate = null;
                        let driver = null;

                        item.dependencies.forEach(depId => {
                            const parent = allItems.get(depId);
                            if (parent && parent.effectiveEndDate) {
                                const parentEndDate = parseDate(parent.effectiveEndDate);
                                if (!latestParentEndDate || parentEndDate > latestParentEndDate) {
                                    latestParentEndDate = parentEndDate;
                                    driver = parent;
                                }
                            }
                        });

                        if (latestParentEndDate) {
                            const newStartDate = new Date(latestParentEndDate);
                            newStartDate.setDate(newStartDate.getDate() + 1); // Dependent starts day after
                            const newStartDateStr = newStartDate.toISOString().split('T')[0];
                            
                            const oldStartDate = item.startDate ? parseDate(item.startDate) : null;
                            const oldEndDate = item.endDate ? parseDate(item.endDate) : null;
                            let duration = null;

                            if (oldStartDate && oldEndDate) {
                                duration = oldEndDate.getTime() - oldStartDate.getTime();
                            }

                            item.startDate = newStartDateStr;

                            if (duration !== null) {
                                const newEndDate = new Date(newStartDate.getTime() + duration);
                                item.endDate = newEndDate.toISOString().split('T')[0];
                            }
                            
                            item.isDriven = true;
                            item.driverName = driver.name;
                        }
                    }
                });
                 // Re-run rollups after each pass to propagate date changes upwards
                calculateRollups();
            }
        }


        // --- RENDER ---
        function renderProjects() {
            calculateRollups();
            resolveDependencies(); // This will now automatically handle date updates
            projectsContainer.innerHTML = '';
            const sortedProjects = [...projects].sort((a, b) => {
                if (a.overallProgress >= 100 && b.overallProgress < 100) return 1;
                if (a.overallProgress < 100 && b.overallProgress >= 100) return -1;
                return sortByEndDate(a, b, 'endDate');
            });

            sortedProjects.forEach((project) => {
                const projectCard = document.createElement('div');
                projectCard.className = `project-card bg-white dark:bg-slate-900 p-3 rounded-xl shadow-md border border-gray-200 dark:border-gray-800`;
                let completionIcon = project.overallProgress >= 100 ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-green-500 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>` : '';

                projectCard.innerHTML = `
                    <div class="flex justify-between items-center mb-3">
                        <div class="flex items-center gap-2 flex-grow min-w-0">
                            ${completionIcon}
                            <button onclick="toggleProjectCollapse(${project.id})" class="p-1 rounded-full hover:bg-gray-100 dark:hover:bg-slate-800 flex-shrink-0">
                                <svg id="chevron-${project.id}" class="w-5 h-5 text-gray-500 chevron ${project.collapsed ? '-rotate-90' : ''}" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
                            </button>
                            <h3 class="text-xl font-bold truncate editable-text" onclick="makeEditable(this, 'updateProjectName', ${project.id})">${project.name}</h3>
                            <span class="text-sm font-medium text-gray-500 flex-shrink-0">${Math.round(project.overallProgress)}%</span>
                        </div>
                        <div class="flex items-center gap-2 text-sm text-gray-500 flex-shrink-0">
                            <div class="date-input-container">
                                <input type="text" value="${project.startDate ? formatDate(parseDate(project.startDate)) : ''}" placeholder="Start Date" class="date-input" data-project-id="${project.id}" data-type="project-start" data-date="${project.startDate || ''}" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                                <div class="date-input-icon-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg></div>
                            </div>
                            <div class="date-input-container">
                                <input type="text" value="${project.endDate ? formatDate(parseDate(project.endDate)) : ''}" placeholder="End Date" class="date-input" data-project-id="${project.id}" data-type="project-end" data-date="${project.endDate || ''}" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                                <div class="date-input-icon-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg></div>
                            </div>
                        </div>
                        <button onclick="deleteProject(${project.id})" class="text-gray-400 hover:text-red-500 transition-colors text-xl font-bold ml-4 flex-shrink-0">&times;</button>
                    </div>
                     <div id="project-body-${project.id}" class="${project.collapsed ? 'hidden' : ''}">
                        <div id="chart-${project.id}" class="w-full h-48 mb-3 relative"></div>
                        <div id="phases-${project.id}" class="space-y-2"></div>
                        <div class="mt-3">
                            <button onclick="toggleLog(${project.id})" class="text-xs font-semibold text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 flex items-center gap-1">
                                <svg id="log-chevron-${project.id}" class="w-4 h-4 chevron -rotate-90" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
                                Change Log
                            </button>
                            <div id="log-container-${project.id}" class="hidden mt-2 p-2 bg-gray-50 dark:bg-slate-800/50 rounded-md">${renderLog(project)}</div>
                        </div>
                    </div>
                `;
                projectsContainer.appendChild(projectCard);
                renderPhaseList(project);
                if (!project.collapsed && project.startDate && project.endDate) {
                    drawChart(project);
                } else if (!project.startDate || !project.endDate) {
                    document.getElementById(`chart-${project.id}`).innerHTML = `<div class="flex items-center justify-center h-full text-gray-400">Set project start and end dates to see progress chart.</div>`;
                }
            });
            renderDeletedProjectsLog();
        }
        
        function getDependencyIcon(item) {
            const dependentCount = item.dependents?.length || 0;
            const isDependentSource = dependentCount > 0; // This item is a parent to others
            const isParentSource = (item.dependencies?.length || 0) > 0; // This item has parents
            let dependentSourceClass = isDependentSource ? 'is-dependent-source' : '';
            let parentSourceClass = isParentSource ? 'is-parent-source' : '';

            return `
                <div class="dependency-container">
                    <div class="dependency-circle ${dependentSourceClass}" 
                         onmouseover="showDependencyTooltip(event, ${item.id})" 
                         onmouseout="hideDependencyTooltip()"
                         onclick="startDependencyMode(${item.id})">${isDependentSource ? `<span>${dependentCount}</span>` : ''}</div>
                    <div class="dependency-circle ${parentSourceClass}"
                         onmouseover="showDependencyTooltip(event, ${item.id})"
                         onmouseout="hideDependencyTooltip()"
                         onclick="handleCircleClick(${item.id})"></div>
                </div>
            `;
        }


        function renderPhaseList(project) {
            const phaseContainer = document.getElementById(`phases-${project.id}`);
            let html = '';
            const sortedPhases = [...project.phases].sort((a, b) => sortByEndDate(a, b, 'effectiveEndDate'));

            sortedPhases.forEach(phase => {
                const hasTasks = phase.tasks && phase.tasks.length > 0;
                const toggleButton = hasTasks ?
                    `<button onclick="togglePhaseCollapse(${project.id}, ${phase.id})" class="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-slate-700 flex-shrink-0">
                        <svg id="phase-chevron-${phase.id}" class="w-4 h-4 text-gray-500 chevron ${phase.collapsed ? '-rotate-90' : ''}" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
                    </button>` : `<div class="w-6 h-6 flex-shrink-0"></div>`; // Placeholder

                const depClass = dependencyMode && firstSelectedItem?.id !== phase.id ? 'dependency-candidate' : '';
                const selectedClass = firstSelectedItem?.id === phase.id ? 'dependency-selected' : '';
                const drivenDot = phase.isDriven ? `<div class="driven-by-dot" title="Starts after: ${phase.driverName}"></div>` : '<div class="w-2"></div>';
                html += `
                    <div class="bg-gray-100 dark:bg-slate-800/50 rounded-lg p-3 phase-row ${depClass} ${selectedClass}" data-id="${phase.id}" data-type="phase" data-project-id="${project.id}">
                        <div class="flex items-center gap-3 item-main-row">
                            ${toggleButton}
                             ${drivenDot}
                            <div class="text-xs font-bold text-gray-500 dark:text-gray-400 w-10 text-center flex-shrink-0">${Math.round(phase.progress || 0)}%</div>
                            <span class="font-semibold flex-grow editable-text" onclick="makeEditable(this, 'updatePhaseName', ${project.id}, ${phase.id})">${phase.name}</span>
                            ${getDependencyIcon(phase)}
                            <div class="flex items-center gap-2 text-sm text-gray-500">
                                <div class="date-input-container"><input type="text" value="${phase.effectiveStartDate ? formatDate(parseDate(phase.effectiveStartDate)) : ''}" placeholder="Start" readonly class="date-input bg-gray-200 dark:bg-slate-700" disabled></div>
                                <div class="date-input-container"><input type="text" value="${phase.effectiveEndDate ? formatDate(parseDate(phase.effectiveEndDate)) : ''}" placeholder="End" readonly class="date-input bg-gray-200 dark:bg-slate-700" disabled></div>
                            </div>
                            <button onclick="deletePhase(${project.id}, ${phase.id})" class="text-gray-400 hover:text-red-500 text-xl font-bold">&times;</button>
                        </div>
                        <div id="tasks-container-${phase.id}" class="pl-12 mt-2 space-y-2 pt-2 border-t border-gray-200 dark:border-slate-700/50 ${phase.collapsed ? 'hidden' : ''}">${renderTaskList(project.id, phase.id, phase.tasks)}</div>
                    </div>`;
            });
             html += `
                <div class="mt-2 pl-4">
                     <div class="flex items-center gap-2">
                        <input type="text" id="new-phase-name-${project.id}" placeholder="Add a new phase..." class="flex-grow w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-sm h-[28px]" onkeydown="if(event.key==='Enter') addPhase(${project.id})">
                        <button onclick="addPhase(${project.id})" class="bg-gray-200 dark:bg-gray-700 font-semibold rounded-md text-sm btn-sm">Add</button>
                    </div>
                </div>`;
            phaseContainer.innerHTML = html;
        }

        function renderTaskList(projectId, phaseId, tasks) {
            let html = '';
            const sortedTasks = [...tasks].sort((a, b) => sortByEndDate(a, b, 'effectiveEndDate'));
            const iconHtml = `<div class="date-input-icon-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg></div>`;
            sortedTasks.forEach(task => {
                const hasSubtasks = task.subtasks && task.subtasks.length > 0;
                let taskControlHtml = hasSubtasks ? `<div class="text-xs font-bold text-gray-500 dark:text-gray-400 w-10 text-center flex-shrink-0">${Math.round(task.progress || 0)}%</div>` : `<input type="checkbox" class="custom-checkbox" onchange="toggleTaskComplete(${projectId}, ${phaseId}, ${task.id})" ${task.completed ? 'checked' : ''}>`;
                const toggleButton = hasSubtasks ? 
                    `<button onclick="toggleTaskCollapse(${projectId}, ${phaseId}, ${task.id})" class="p-1 rounded-full hover:bg-gray-200 dark:hover:bg-slate-700 flex-shrink-0">
                        <svg id="task-chevron-${task.id}" class="w-4 h-4 text-gray-500 chevron ${task.collapsed ? '-rotate-90' : ''}" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>
                    </button>` : `<div class="w-6 h-6 flex-shrink-0"></div>`; // Placeholder
                const depClass = dependencyMode && firstSelectedItem?.id !== task.id ? 'dependency-candidate' : '';
                const selectedClass = firstSelectedItem?.id === task.id ? 'dependency-selected' : '';
                const drivenDot = task.isDriven ? `<div class="driven-by-dot" title="Starts after: ${task.driverName}"></div>` : '<div class="w-2"></div>';
                html += `
                    <div class="bg-gray-50 dark:bg-slate-800/50 rounded-lg p-2 task-row ${depClass} ${selectedClass}" data-id="${task.id}" data-type="task" data-project-id="${projectId}" data-phase-id="${phaseId}">
                        <div class="flex items-center gap-3 item-main-row">
                             ${toggleButton}
                            ${drivenDot}
                            ${taskControlHtml}
                            <div class="flex-grow flex items-center gap-2">
                                <span class="font-medium editable-text" onclick="makeEditable(this, 'updateTaskName', ${projectId}, ${phaseId}, ${task.id})">${task.name}</span>
                                <button onclick="showAddSubtaskInput(${task.id})" class="add-subtask-btn items-center gap-1 text-xs bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 font-semibold rounded-md px-2 py-1 flex-shrink-0">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg>
                                    <span>Subtask</span>
                                </button>
                            </div>
                            ${getDependencyIcon(task)}
                            <div class="flex items-center gap-2 text-sm text-gray-500">
                                <div class="date-input-container">
                                    <input type="text" value="${task.effectiveStartDate ? formatDate(parseDate(task.effectiveStartDate)) : ''}" placeholder="Start" class="date-input ${hasSubtasks || task.isDriven ? 'bg-gray-100 dark:bg-slate-800' : ''}" ${hasSubtasks || task.isDriven ? 'disabled' : ''} data-project-id="${projectId}" data-phase-id="${phaseId}" data-task-id="${task.id}" data-type="task-start" data-date="${task.startDate || ''}" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                                    ${!hasSubtasks && !task.isDriven ? iconHtml : ''}
                                </div>
                                <div class="date-input-container">
                                    <input type="text" value="${task.effectiveEndDate ? formatDate(parseDate(task.effectiveEndDate)) : ''}" placeholder="End" class="date-input ${hasSubtasks ? 'bg-gray-100 dark:bg-slate-800' : ''}" ${hasSubtasks ? 'disabled' : ''} data-project-id="${projectId}" data-phase-id="${phaseId}" data-task-id="${task.id}" data-type="task-end" data-date="${task.endDate || ''}" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                                    ${!hasSubtasks ? iconHtml : ''}
                                </div>
                            </div>
                            <button onclick="deleteTask(${projectId}, ${phaseId}, ${task.id})" class="text-gray-400 hover:text-red-500 text-xl font-bold">&times;</button>
                        </div>
                        <div id="subtasks-container-${task.id}" class="pl-12 mt-2 space-y-2 pt-2 border-t border-gray-200 dark:border-slate-700/50 ${task.collapsed || !hasSubtasks ? 'hidden' : ''}">
                            ${renderSubtaskList(projectId, phaseId, task.id, task.subtasks || [])}
                        </div>
                        <div id="add-subtask-form-${task.id}" class="hidden ml-12 mt-2">
                             <div class="flex items-center gap-2">
                                <input type="text" id="new-subtask-name-${task.id}" placeholder="Add subtask..." class="flex-grow w-full px-2 py-1 border border-gray-200 dark:border-gray-700 rounded-md bg-white dark:bg-gray-800 text-xs h-[28px]" onkeydown="if(event.key==='Enter') addSubtask(${projectId}, ${phaseId}, ${task.id})">
                                <button onclick="addSubtask(${projectId}, ${phaseId}, ${task.id})" class="bg-gray-200 dark:bg-gray-700 font-semibold rounded-md text-xs btn-sm">Add</button>
                             </div>
                        </div>
                    </div>`;
            });
            html += `
                <div>
                    <div class="flex items-center gap-2">
                        <input type="text" id="new-task-name-${phaseId}" placeholder="Add a new task..." class="flex-grow w-full px-2 py-1 border border-gray-200 dark:border-gray-700 rounded-md bg-white dark:bg-gray-800 text-xs h-[28px]" onkeydown="if(event.key==='Enter') addTask(${projectId}, ${phaseId})">
                        <button onclick="addTask(${projectId}, ${phaseId})" class="bg-gray-200 dark:bg-gray-700 font-semibold rounded-md text-xs btn-sm">Add</button>
                    </div>
                </div>`;
            return html;
        }

        function renderSubtaskList(projectId, phaseId, taskId, subtasks) {
            if (!subtasks || subtasks.length === 0) {
                return '';
            }
            let html = '<div class="ml-12 mt-1 space-y-1 pt-1">';
            const sortedSubtasks = [...subtasks].sort((a,b) => sortByEndDate(a, b, 'endDate'));
            const iconHtml = `<div class="date-input-icon-wrapper"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg></div>`;
            sortedSubtasks.forEach(subtask => {
                const depClass = dependencyMode && firstSelectedItem?.id !== subtask.id ? 'dependency-candidate' : '';
                const selectedClass = firstSelectedItem?.id === subtask.id ? 'dependency-selected' : '';
                const drivenDot = subtask.isDriven ? `<div class="driven-by-dot" title="Starts after: ${subtask.driverName}"></div>` : '<div class="w-2"></div>';
                html += `
                    <div class="flex items-center gap-3 subtask-row ${depClass} ${selectedClass}" data-id="${subtask.id}" data-type="subtask" data-project-id="${projectId}" data-phase-id="${phaseId}" data-task-id="${taskId}">
                        ${drivenDot}
                        <input type="checkbox" class="custom-checkbox" onchange="toggleSubtaskComplete(${projectId}, ${phaseId}, ${taskId}, ${subtask.id})" ${subtask.completed ? 'checked' : ''}>
                        <span class="text-sm text-gray-700 dark:text-gray-300 flex-grow ${subtask.completed ? 'line-through opacity-60' : ''} editable-text" onclick="makeEditable(this, 'updateSubtaskName', ${projectId}, ${phaseId}, ${taskId}, ${subtask.id})">${subtask.name}</span>
                        ${getDependencyIcon(subtask)}
                        <div class="flex items-center gap-2 text-sm text-gray-500">
                             <div class="date-input-container">
                                <input type="text" value="${subtask.startDate ? formatDate(parseDate(subtask.startDate)) : ''}" placeholder="Start" class="date-input ${subtask.isDriven ? 'bg-gray-100 dark:bg-slate-800' : ''}" ${subtask.isDriven ? 'disabled' : ''} data-project-id="${projectId}" data-phase-id="${phaseId}" data-task-id="${taskId}" data-subtask-id="${subtask.id}" data-type="subtask-start" data-date="${subtask.startDate || ''}" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                                 ${!subtask.isDriven ? iconHtml : ''}
                             </div>
                             <div class="date-input-container">
                                <input type="text" value="${subtask.endDate ? formatDate(parseDate(subtask.endDate)) : ''}" placeholder="End" class="date-input" data-project-id="${projectId}" data-phase-id="${phaseId}" data-task-id="${taskId}" data-subtask-id="${subtask.id}" data-type="subtask-end" data-date="${subtask.endDate || ''}" oninput="formatDateInput(event)" onblur="handleManualDateInput(event)">
                                ${iconHtml}
                            </div>
                        </div>
                        <button onclick="deleteSubtask(${projectId}, ${phaseId}, ${taskId}, ${subtask.id})" class="text-gray-400 hover:text-red-500 text-xl font-bold w-5 text-center flex-shrink-0">&times;</button>
                    </div>`;
            });
            return html + '</div>';
        }

        function renderLog(project) {
            if (!project.logs || project.logs.length === 0) return '<p class="text-xs text-gray-500 dark:text-gray-400">No changes logged.</p>';
            let tableHtml = `<table class="w-full text-xs font-mono text-gray-700 dark:text-gray-300"><thead><tr class="border-b border-gray-200 dark:border-slate-700"><th class="text-left p-1 w-1/4">Timestamp</th><th class="text-left p-1 w-1/4">Item</th><th class="text-left p-1">Change</th><th class="text-left p-1">Reason</th></tr></thead><tbody>`;
            [...project.logs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach(log => {
                let changeText = '';
                if (log.type === 'deletion') {
                    changeText = 'Deleted';
                } else {
                    changeText = `${log.from ? formatDate(parseDate(log.from)) : 'None'} -> ${formatDate(parseDate(log.to))}`;
                }
                tableHtml += `<tr class="border-b border-gray-100 dark:border-slate-700/50"><td class="p-1 align-top">${formatLogTimestamp(new Date(log.timestamp))}</td><td class="p-1 align-top">${log.item}</td><td class="p-1 align-top">${changeText}</td><td class="p-1 align-top">${log.comment}</td></tr>`;
            });
            return tableHtml + '</tbody></table>';
        }

        function renderDeletedProjectsLog() {
            const container = document.getElementById('deleted-projects-log-content');
            const toggleBtn = document.getElementById('toggle-deleted-log-btn');
            const chevron = document.getElementById('deleted-log-chevron');

            if (!deletedProjectLogs || deletedProjectLogs.length === 0) {
                container.innerHTML = '';
                toggleBtn.classList.add('hidden');
                return;
            }

            toggleBtn.classList.remove('hidden');
            if(deletedLogCollapsed){
                container.classList.add('hidden');
                chevron.classList.add('-rotate-90');
            } else {
                container.classList.remove('hidden');
                chevron.classList.remove('-rotate-90');
            }


            let tableHtml = `<div class="bg-white dark:bg-slate-900 p-3 rounded-xl shadow-md border border-gray-200 dark:border-gray-800">
                <table class="w-full text-xs font-mono text-gray-700 dark:text-gray-300">
                    <thead>
                        <tr class="border-b border-gray-200 dark:border-slate-700">
                            <th class="text-left p-1 w-1/4">Timestamp</th>
                            <th class="text-left p-1 w-1/4">Item</th>
                            <th class="text-left p-1">Change</th>
                            <th class="text-left p-1">Reason</th>
                        </tr>
                    </thead>
                    <tbody>`;

            [...deletedProjectLogs].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).forEach(log => {
                tableHtml += `<tr class="border-b border-gray-100 dark:border-slate-700/50">
                                <td class="p-1 align-top">${formatLogTimestamp(new Date(log.timestamp))}</td>
                                <td class="p-1 align-top">${log.item}</td>
                                <td class="p-1 align-top">Deleted</td>
                                <td class="p-1 align-top">${log.comment}</td>
                              </tr>`;
            });

            tableHtml += '</tbody></table></div>';
            container.innerHTML = tableHtml;
        }

        function drawChart(project) {
            const container = d3.select(`#chart-${project.id}`);
            if (container.empty() || !project.startDate || !project.endDate) return;
            setTimeout(() => {
                const width = container.node().getBoundingClientRect().width;
                if (width <= 0) return;
                container.selectAll("*").remove();
                
                // Add fullscreen button
                container.append('button')
                    .html('<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 1v4m0 0h-4m4 0l-5-5" /></svg>')
                    .attr('class', 'absolute bottom-1 right-1 p-1.5 bg-gray-200 dark:bg-gray-700 rounded-full text-gray-600 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600')
                    .on('click', () => showFullscreenChart(project.id));
                
                const margin = { top: 10, right: 20, bottom: 20, left: 40 },
                    chartWidth = width - margin.left - margin.right,
                    height = container.node().getBoundingClientRect().height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", chartWidth + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleTime().range([0, chartWidth]),
                    y = d3.scaleLinear().range([height, 0]);
                const startDate = parseDate(project.startDate),
                    endDate = parseDate(project.endDate);
                x.domain([startDate, endDate]);
                y.domain([0, 100]);
                svg.append("g").attr("class", "chart-grid").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(5).tickFormat(formatDate));
                svg.append("g").attr("class", "chart-grid").call(d3.axisLeft(y).ticks(5).tickFormat(d => `${d}%`));

                const endDateChanges = project.logs
                    .filter(log => log.item.includes(`Project '${project.name}' end date`) && log.from)
                    .map(log => log.from);
                if (project.originalEndDate) {
                    endDateChanges.push(project.originalEndDate);
                }
                const uniquePriorEndDates = [...new Set(endDateChanges)].filter(d => d !== project.endDate);

                uniquePriorEndDates.forEach(dateStr => {
                    const date = parseDate(dateStr);
                    if (date) {
                        svg.append("line")
                            .attr("class", "ghost-finish-line")
                            .attr("x1", x(date))
                            .attr("y1", 0)
                            .attr("x2", x(date))
                            .attr("y2", height);
                    }
                });

                const today = new Date();
                if (today >= startDate && today <= endDate) {
                    svg.append("line")
                        .attr("class", "today-line")
                        .attr("x1", x(today))
                        .attr("y1", 0)
                        .attr("x2", x(today))
                        .attr("y2", height);
                }

                svg.append("line").attr("class", "planned-line").attr("x1", x(startDate)).attr("y1", y(0)).attr("x2", x(endDate)).attr("y2", y(100));
                svg.append("line").attr("class", "finish-line").attr("x1", x(endDate)).attr("y1", 0).attr("x2", x(endDate)).attr("y2", height);

                const allTasks = project.phases.flatMap(phase => phase.tasks).filter(task => task.effectiveEndDate);
                const firstActivityDate = parseDate(getBoundaryDate(allTasks, 'earliest')) || startDate;
                const pathData = [{ date: firstActivityDate, progress: 0 }];
                let cumulativeProgress = 0;

                allTasks.sort((a,b) => parseDate(a.effectiveEndDate) - parseDate(b.effectiveEndDate)).forEach(task => {
                    const dateForPoint = parseDate(task.effectiveEndDate);
                    if (dateForPoint) {
                        cumulativeProgress += 100 / (allTasks.length || 1);
                        pathData.push({ date: dateForPoint, progress: cumulativeProgress, completed: task.completed, name: task.name });
                    }
                });

                const line = d3.line().x(d => x(d.date)).y(d => y(d.progress));
                const totalDuration = endDate.getTime() - startDate.getTime();
                const getPlannedProgress = date => totalDuration <= 0 ? 0 : Math.min(100, (date.getTime() - startDate.getTime()) / totalDuration * 100);
                for (let i = 0; i < pathData.length - 1; i++) {
                    const segment = [pathData[i], pathData[i+1]], endPoint = segment[1];
                    const colorClass = endPoint.date > endDate ? 'stroke-red-500' : (endPoint.progress >= getPlannedProgress(endPoint.date) ? 'stroke-green-500' : 'stroke-red-500');
                    svg.append("path").datum(segment).attr("class", `${endPoint.completed ? 'actual-line' : 'projected-line'} ${colorClass}`).attr("d", line);
                }
                svg.selectAll(".actual-point").data(pathData.slice(1).filter(d=>d.completed)).enter().append("circle").attr("class", "actual-point").attr("cx", d => x(d.date)).attr("cy", d => y(d.progress)).attr("fill", d => d.date > endDate ? '#ef4444' : (d.progress >= getPlannedProgress(d.date) ? '#22c55e' : '#ef4444'));

                const sortedPhases = [...project.phases]
                    .filter(p => p.effectiveEndDate)
                    .sort((a, b) => parseDate(a.effectiveEndDate) - parseDate(b.effectiveEndDate));

                const phaseMarkers = svg.selectAll(".phase-marker")
                    .data(sortedPhases)
                    .enter()
                    .append("g")
                    .attr("class", "phase-marker")
                    .attr("transform", (d, i) => {
                        const phaseEndDate = parseDate(d.effectiveEndDate);
                        
                        let tasksInPhaseOrBefore = allTasks.filter(t => parseDate(t.effectiveEndDate) <= phaseEndDate);
                        let phaseEndProgress = (tasksInPhaseOrBefore.length / (allTasks.length || 1)) * 100;

                        return `translate(${x(phaseEndDate)}, ${y(phaseEndProgress)})`;
                    });

                phaseMarkers.append("circle")
                    .attr("class", "phase-marker-circle");

                phaseMarkers.append("text")
                    .attr("class", "phase-marker-text")
                    .text((d, i) => `P${i + 1}`);

            }, 0);
        }
        
        function showFullscreenChart(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project) return;
            fullscreenModal.style.display = 'block';
            drawFullscreenChart(project);
        }

        function drawFullscreenChart(project) {
            const container = d3.select("#fullscreen-chart-container");
            container.selectAll("svg").remove(); // Clear previous chart
            container.selectAll(".chart-tooltip").remove(); // Clear tooltips

            const tooltip = d3.select("body").append("div").attr("class", "chart-tooltip");

            const width = container.node().getBoundingClientRect().width;
            const height = container.node().getBoundingClientRect().height;
            const margin = { top: 40, right: 50, bottom: 40, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleTime().range([0, chartWidth]);
            const y = d3.scaleLinear().range([chartHeight, 0]);

            const startDate = parseDate(project.startDate);
            const endDate = parseDate(project.endDate);
            x.domain([startDate, endDate]);
            y.domain([0, 100]);
            
            const timeDiff = endDate.getTime() - startDate.getTime();
            const days = timeDiff / (1000 * 3600 * 24);

            let tickInterval;
            if (days > 365) {
                tickInterval = d3.timeMonth.every(3);
            } else if (days > 180) {
                tickInterval = d3.timeMonth.every(1);
            } else if (days > 60) {
                tickInterval = d3.timeWeek.every(2);
            } else {
                 tickInterval = d3.timeWeek.every(1);
            }


            // More granular axis
            svg.append("g")
                .attr("class", "chart-grid")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(x).ticks(tickInterval).tickFormat(d3.timeFormat("%b %d")));

            svg.append("g")
                .attr("class", "chart-grid")
                .call(d3.axisLeft(y).ticks(10).tickFormat(d => `${d}%`));
            
            svg.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", 0 - (margin.top / 2))
                .attr("text-anchor", "middle")
                .attr("class", "text-lg font-bold fill-current")
                .text(`${project.name} - Progress Chart`);

            // Planned line and finish line
            svg.append("line").attr("class", "planned-line").attr("x1", x(startDate)).attr("y1", y(0)).attr("x2", x(endDate)).attr("y2", y(100));
            svg.append("line").attr("class", "finish-line").attr("x1", x(endDate)).attr("y1", 0).attr("x2", x(endDate)).attr("y2", chartHeight);

            // Today line
            const today = new Date();
            if (today >= startDate && today <= endDate) {
                svg.append("line").attr("class", "today-line").attr("x1", x(today)).attr("y1", 0).attr("x2", x(today)).attr("y2", chartHeight);
            }
            
            // --- MODIFICATION START: Combine Task and Phase data ---
            const allTasksWithPhase = [];
            project.phases.forEach(phase => {
                phase.tasks.forEach(task => {
                    if (task.effectiveEndDate) {
                        allTasksWithPhase.push({ ...task, phaseName: phase.name });
                    }
                });
            });

            const firstActivityDate = parseDate(getBoundaryDate(allTasksWithPhase, 'earliest')) || startDate;
            const pathData = [{ date: firstActivityDate, progress: 0 }];
            let cumulativeProgress = 0;

            allTasksWithPhase.sort((a,b) => parseDate(a.effectiveEndDate) - parseDate(b.effectiveEndDate)).forEach(task => {
                const dateForPoint = parseDate(task.effectiveEndDate);
                if (dateForPoint) {
                    cumulativeProgress += 100 / (allTasksWithPhase.length || 1);
                    pathData.push({ 
                        date: dateForPoint, 
                        progress: cumulativeProgress, 
                        completed: task.completed, 
                        name: task.name,
                        phaseName: task.phaseName,
                        percentComplete: Math.round(task.progress)
                    });
                }
            });
            // --- MODIFICATION END ---

            const line = d3.line().x(d => x(d.date)).y(d => y(d.progress));
            // --- MODIFICATION START: Match Color Logic ---
            const totalDuration = endDate.getTime() - startDate.getTime();
            const getPlannedProgress = date => totalDuration <= 0 ? 0 : Math.min(100, (date.getTime() - startDate.getTime()) / totalDuration * 100);
            
            // Draw path segments
            for (let i = 0; i < pathData.length - 1; i++) {
                const segment = [pathData[i], pathData[i+1]], endPoint = segment[1];
                const colorClass = endPoint.date > endDate ? 'stroke-red-500' : (endPoint.progress >= getPlannedProgress(endPoint.date) ? 'stroke-green-500' : 'stroke-red-500');
                svg.append("path").datum(segment).attr("class", `${endPoint.completed ? 'actual-line' : 'projected-line'} ${colorClass}`).attr("d", line);
            }

            // Draw points
            svg.selectAll(".task-point")
                .data(pathData.slice(1))
                .enter().append("circle")
                .attr("class", "task-point actual-point")
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.progress))
                .attr("fill", d => d.date > endDate ? '#ef4444' : (d.progress >= getPlannedProgress(d.date) ? '#22c55e' : '#ef4444'));
            // --- MODIFICATION END ---

            // --- MODIFICATION START: Updated Task Labels with Phase Name ---
            const labels = svg.selectAll(".task-label-container")
                .data(pathData.slice(1))
                .enter().append("foreignObject")
                .attr("class", "task-label-container")
                .attr("width", 180) 
                .attr("height", 60); // Increased height for phase name

            labels.each(function(d) {
                const fo = d3.select(this);
                fo.append("xhtml:div")
                    .attr("class", "p-2 rounded-md text-xs bg-gray-100 dark:bg-slate-800 border border-gray-200 dark:border-slate-700 h-full")
                    .html(`<div class="font-bold text-blue-500 truncate">${d.phaseName}</div><strong class="truncate">${d.name}</strong><br>${formatDate(d.date)} - ${d.percentComplete}%`);

                const pointX = x(d.date);
                const pointY = y(d.progress);
                const foWidth = 180;
                const foHeight = 60;

                let foX = pointX + 10;
                let foY = pointY - (foHeight / 2);

                if (foX + foWidth > chartWidth) {
                    foX = pointX - foWidth - 10;
                }
                 if (foY < 0) {
                    foY = 0;
                }
                if (foY + foHeight > chartHeight) {
                    foY = chartHeight - foHeight;
                }

                fo.attr("x", foX).attr("y", foY);
            });

            labels.each(function(d, i) {
                const currentLabel = d3.select(this);
                labels.each(function(d2, j) {
                    if (i >= j) return;
                    const otherLabel = d3.select(this);
                    
                    const currentBox = {x: parseFloat(currentLabel.attr("x")), y: parseFloat(currentLabel.attr("y")), width: 180, height: 60};
                    const otherBox = {x: parseFloat(otherLabel.attr("x")), y: parseFloat(otherLabel.attr("y")), width: 180, height: 60};

                    if (
                        currentBox.x < otherBox.x + otherBox.width &&
                        currentBox.x + currentBox.width > otherBox.x &&
                        currentBox.y < otherBox.y + otherBox.height &&
                        currentBox.height + currentBox.y > otherBox.y
                    ) {
                        const newY = currentBox.y + currentBox.height + 2;
                         if (newY + otherBox.height <= chartHeight) {
                            otherLabel.attr("y", newY);
                        }
                    }
                });
            });
             // --- MODIFICATION END ---
        }

        function showDependencyTooltip(event, itemId) {
            const allItems = new Map();
            projects.forEach(p => p.phases.forEach(ph => { allItems.set(ph.id, ph); ph.tasks.forEach(t => { allItems.set(t.id, t); if(t.subtasks) t.subtasks.forEach(st => allItems.set(st.id, st)); }); }));
            const item = allItems.get(itemId);
            if (!item || ((!item.dependents || item.dependents.length === 0) && (!item.dependencies || item.dependencies.length === 0))) {
                return;
            }

            // Find the ultimate root of the dependency chain
            let rootItem = item;
            let visited = new Set();
            while (rootItem.dependencies && rootItem.dependencies.length > 0 && !visited.has(rootItem.id)) {
                visited.add(rootItem.id);
                const parentId = rootItem.dependencies[0];
                const parentItem = allItems.get(parentId);
                if (!parentItem || visited.has(parentId)) break; // Cycle detected or parent not found
                rootItem = parentItem;
            }

            const treeHtml = buildDependencyTree(rootItem.id, itemId, allItems);
            dependencyTooltip.innerHTML = treeHtml;
            dependencyTooltip.classList.remove('hidden');

            const rect = event.target.getBoundingClientRect();
            const containerRect = projectsContainer.getBoundingClientRect();
            
            let top = rect.bottom + window.scrollY + 5;
            let left = rect.left + window.scrollX;

            dependencyTooltip.style.top = `${top}px`;
            dependencyTooltip.style.left = `${left}px`;
            
            // Adjust position if it overflows the viewport
            const tooltipRect = dependencyTooltip.getBoundingClientRect();
            if (tooltipRect.right > window.innerWidth) {
                dependencyTooltip.style.left = `${window.innerWidth - tooltipRect.width - 10}px`;
            }
             if (tooltipRect.bottom > window.innerHeight) {
                dependencyTooltip.style.top = `${top - tooltipRect.height - rect.height - 10}px`;
            }
        }

        function hideDependencyTooltip() {
            dependencyTooltip.classList.add('hidden');
        }

        function buildDependencyTree(itemId, highlightedId, allItems, visited = new Set()) {
            if (visited.has(itemId)) return ''; // Prevent infinite loops
            visited.add(itemId);

            const item = allItems.get(itemId);
            if (!item) return '';

            let highlightClass = item.id === highlightedId ? 'highlight' : '';
            
            let childrenHtml = '';
            if (item.dependents && item.dependents.length > 0) {
                childrenHtml += '<div class="node-children">';
                item.dependents.forEach(childId => {
                    childrenHtml += buildDependencyTree(childId, highlightedId, allItems, visited);
                });
                childrenHtml += '</div>';
            }

            return `
                <div class="dependency-tree-node">
                    <div class="node-content ${highlightClass}">
                        ${item.name}
                    </div>
                    ${childrenHtml}
                </div>
            `;
        }

        function formatDateInput(event) { let value = event.target.value.replace(/\D/g, ''); if (value.length > 2) value = value.substring(0, 2) + '/' + value.substring(2); if (value.length > 5) value = value.substring(0, 5) + '/' + value.substring(5, 7); event.target.value = value; }
        function handleManualDateInput(event) {
            const input = event.target, dateStr = input.value;
            const revert = () => { input.value = input.dataset.date ? formatDate(parseDate(input.dataset.date)) : ''; };
            if (!/^\d{2}\/\d{2}\/\d{2}$/.test(dateStr)) { revert(); return; }
            const [month, day, year] = dateStr.split('/').map(p => parseInt(p, 10));
            const dateObj = new Date(year + 2000, month - 1, day);
            if (dateObj.getFullYear() !== year + 2000 || dateObj.getMonth() !== month - 1 || dateObj.getDate() !== day) { revert(); return; }
            const newDate = dateObj.toISOString().split('T')[0], oldDate = input.dataset.date || null;
            const context = { type: input.dataset.type, projectId: parseInt(input.dataset.projectId), phaseId: parseInt(input.dataset.phaseId), taskId: parseInt(input.dataset.taskId), subtaskId: parseInt(input.dataset.subtaskId), element: input };
            if (input.dataset.type.startsWith('new-project')) { input.dataset.date = newDate; return; }
            if (oldDate && oldDate !== newDate) {
                pendingDateChange = { context, newDate };
                reasonModalTitle.textContent = 'Reason for Date Change';
                reasonModalDetails.textContent = `Changing date from ${formatDate(parseDate(oldDate))} to ${formatDate(parseDate(newDate))}.`;
                reasonModal.classList.remove('hidden');
                reasonCommentTextarea.focus();
            }
            else if (!oldDate) { updateDate(context, newDate); }
        }
        
        function makeEditable(element, updateFunction, ...args) {
            const originalText = element.innerText;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = originalText;
            input.className = element.className.replace('editable-text', '') + ' inline-input';
            element.replaceWith(input);
            input.focus();

            input.addEventListener('blur', () => {
                const newText = input.value.trim();
                if (newText) {
                    window[updateFunction](...args, newText);
                }
                renderProjects();
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    input.blur();
                }
            });
        }
        
        function showAddSubtaskInput(taskId) {
            const form = document.getElementById(`add-subtask-form-${taskId}`);
            if (form) {
                form.classList.toggle('hidden');
                if (!form.classList.contains('hidden')) {
                    form.querySelector('input').focus();
                }
            }
        }
        
        function addProject() {
            const name = newProjectNameInput.value.trim(); if (!name) return;
            const startDateInput = document.getElementById('new-project-start-date'), endDateInput = document.getElementById('new-project-end-date');
            const startDate = startDateInput.dataset.date || null, endDate = endDateInput.dataset.date || null;
            projects.push({ id: Date.now(), name, startDate, endDate, originalStartDate: startDate, originalEndDate: endDate, collapsed: false, phases: [], logs: [] });
            saveProjects(); newProjectNameInput.value = ''; startDateInput.value = ''; endDateInput.value = ''; delete startDateInput.dataset.date; delete endDateInput.dataset.date; renderProjects();
        }

        function addPhase(projectId) {
            const nameInput = document.getElementById(`new-phase-name-${projectId}`), name = nameInput.value.trim(); if (!name) return;
            const project = projects.find(p => p.id === projectId); if (project) { project.phases.push({ id: Date.now(), name, collapsed: false, tasks: [], dependencies: [], dependents: [] }); saveProjects(); renderProjects(); }
        }

        function addTask(projectId, phaseId) {
            const nameInput = document.getElementById(`new-task-name-${phaseId}`), name = nameInput.value.trim(); if (!name) return;
            const phase = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId); if (phase) { phase.tasks.push({ id: Date.now(), name, startDate: null, endDate: null, completed: false, subtasks: [], dependencies: [], dependents: [] }); saveProjects(); renderProjects(); }
        }

        function addSubtask(projectId, phaseId, taskId) {
            const nameInput = document.getElementById(`new-subtask-name-${taskId}`), name = nameInput.value.trim(); if (!name) return;
            const task = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId)?.tasks.find(t => t.id === taskId); if (task) { if (!task.subtasks) task.subtasks = []; task.subtasks.push({ id: Date.now(), name, startDate: null, endDate: null, completed: false, dependencies: [], dependents: [] }); nameInput.value = ''; saveProjects(); renderProjects(); }
        }

        function updateProjectName(projectId, newName) { const p = projects.find(p => p.id === projectId); if (p) { p.name = newName; saveProjects(); } }
        function updatePhaseName(projectId, phaseId, newName) { const p = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId); if (p) { p.name = newName; saveProjects(); } }
        function updateTaskName(projectId, phaseId, taskId, newName) { const t = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId)?.tasks.find(t => t.id === taskId); if (t) { t.name = newName; saveProjects(); } }
        function updateSubtaskName(projectId, phaseId, taskId, subtaskId, newName) { const s = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId)?.tasks.find(t => t.id === taskId)?.subtasks.find(st => st.id === subtaskId); if (s) { s.name = newName; saveProjects(); } }

        function updateDate(context, value, comment = null) {
            const { projectId, phaseId, taskId, subtaskId, type } = context; const project = projects.find(p => p.id === projectId); if (!project) return; let targetItem, dateField, itemName;
            if (type.startsWith('project')) { targetItem = project; dateField = type.endsWith('start') ? 'startDate' : 'endDate'; itemName = `Project '${project.name}' ${dateField.replace('Date','')} date`; }
            else {
                const phase = project.phases.find(ph => ph.id === phaseId); if (!phase) return; const task = phase.tasks.find(t => t.id === taskId); if (!task) return; itemName = `Task '${task.name}'`;
                if (type.startsWith('task')) { targetItem = task; dateField = type.endsWith('start') ? 'startDate' : 'endDate'; itemName += ` ${dateField.replace('Date','')} date`; }
                else if (type.startsWith('subtask')) { const subtask = task.subtasks.find(st => st.id === subtaskId); if (!subtask) return; targetItem = subtask; dateField = type.endsWith('start') ? 'startDate' : 'endDate'; itemName = `Subtask '${subtask.name}' ${dateField.replace('Date','')} date`; }
            }
            if (targetItem && dateField) { const oldDate = targetItem[dateField]; if (comment) { if (!project.logs) project.logs = []; project.logs.push({ timestamp: new Date().toISOString(), item: itemName, from: oldDate, to: value, comment }); } targetItem[dateField] = value; }
            saveProjects(); renderProjects();
        }

        function toggleTaskComplete(projectId, phaseId, taskId) { const t = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId)?.tasks.find(t => t.id === taskId); if (t) { t.completed = !t.completed; saveProjects(); renderProjects(); } }
        function toggleSubtaskComplete(projectId, phaseId, taskId, subtaskId) { const s = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId)?.tasks.find(t => t.id === taskId)?.subtasks.find(st => st.id === subtaskId); if (s) { s.completed = !s.completed; saveProjects(); renderProjects(); } }
        
        function removeAllDependencies(itemId) {
            const allItems = new Map();
             projects.forEach(p => p.phases.forEach(ph => { allItems.set(ph.id, ph); ph.tasks.forEach(t => { allItems.set(t.id, t); if(t.subtasks) t.subtasks.forEach(st => allItems.set(st.id, st)); }); }));
             
             const itemToRemove = allItems.get(itemId);
             if (!itemToRemove) return;

             // Remove this item from its parents' dependents list
             (itemToRemove.dependencies || []).forEach(parentId => {
                const parent = allItems.get(parentId);
                if (parent && parent.dependents) {
                    parent.dependents = parent.dependents.filter(id => id !== itemId);
                }
             });
             itemToRemove.dependencies = [];

             // Remove this item from its dependents' parents list
             (itemToRemove.dependents || []).forEach(dependentId => {
                const dependent = allItems.get(dependentId);
                if(dependent && dependent.dependencies) {
                    dependent.dependencies = dependent.dependencies.filter(id => id !== itemId);
                }
             });
             itemToRemove.dependents = [];
        }
        
        function deleteProject(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (project) {
                 project.phases.forEach(ph => {
                    removeAllDependencies(ph.id);
                    ph.tasks.forEach(t => {
                        removeAllDependencies(t.id);
                        if(t.subtasks) t.subtasks.forEach(st => removeAllDependencies(st.id));
                    });
                });
                pendingDeletion = {
                    type: 'project',
                    logContext: { projectId },
                    deleteFn: () => {
                        projects = projects.filter(p => p.id !== projectId);
                    },
                    itemName: `Project '${project.name}'`
                };
                reasonModalTitle.textContent = 'Reason for Deletion';
                reasonModalDetails.textContent = `You are about to delete the project: "${project.name}".`;
                reasonModal.classList.remove('hidden');
                reasonCommentTextarea.focus();
            }
        }

        function deletePhase(projectId, phaseId) {
            const project = projects.find(p => p.id === projectId);
            const phase = project?.phases.find(ph => ph.id === phaseId);
            if (phase) {
                removeAllDependencies(phaseId);
                phase.tasks.forEach(t => {
                    removeAllDependencies(t.id);
                    if(t.subtasks) t.subtasks.forEach(st => removeAllDependencies(st.id));
                });
                pendingDeletion = {
                    type: 'phase',
                    logContext: { projectId },
                    deleteFn: () => {
                        project.phases = project.phases.filter(ph => ph.id !== phaseId);
                    },
                    itemName: `Phase '${phase.name}' from project '${project.name}'`
                };
                reasonModalTitle.textContent = 'Reason for Deletion';
                reasonModalDetails.textContent = `You are about to delete the phase: "${phase.name}".`;
                reasonModal.classList.remove('hidden');
                reasonCommentTextarea.focus();
            }
        }

        function deleteTask(projectId, phaseId, taskId) {
            const project = projects.find(p => p.id === projectId);
            const phase = project?.phases.find(ph => ph.id === phaseId);
            const task = phase?.tasks.find(t => t.id === taskId);
            if (task) {
                removeAllDependencies(taskId);
                 if(task.subtasks) task.subtasks.forEach(st => removeAllDependencies(st.id));
                pendingDeletion = {
                    type: 'task',
                    logContext: { projectId },
                    deleteFn: () => {
                        phase.tasks = phase.tasks.filter(t => t.id !== taskId);
                    },
                    itemName: `Task '${task.name}' from phase '${phase.name}'`
                };
                reasonModalTitle.textContent = 'Reason for Deletion';
                reasonModalDetails.textContent = `You are about to delete the task: "${task.name}".`;
                reasonModal.classList.remove('hidden');
                reasonCommentTextarea.focus();
            }
        }

        function deleteSubtask(projectId, phaseId, taskId, subtaskId) {
            const project = projects.find(p => p.id === projectId);
            const task = project?.phases.find(ph => ph.id === phaseId)?.tasks.find(t => t.id === taskId);
            const subtask = task?.subtasks.find(st => st.id === subtaskId);
            if (subtask) {
                removeAllDependencies(subtaskId);
                pendingDeletion = {
                    type: 'subtask',
                    logContext: { projectId },
                    deleteFn: () => {
                        task.subtasks = task.subtasks.filter(st => st.id !== subtaskId);
                    },
                    itemName: `Subtask '${subtask.name}' from task '${task.name}'`
                };
                reasonModalTitle.textContent = 'Reason for Deletion';
                reasonModalDetails.textContent = `You are about to delete the subtask: "${subtask.name}".`;
                reasonModal.classList.remove('hidden');
                reasonCommentTextarea.focus();
            }
        }
        
        function toggleProjectCollapse(projectId) {
            const p = projects.find(p => p.id === projectId);
            if (p) {
                p.collapsed = !p.collapsed;
                saveProjects();
                document.getElementById(`project-body-${projectId}`).classList.toggle('hidden');
                document.getElementById(`chevron-${projectId}`).classList.toggle('-rotate-90');
                if (!p.collapsed && p.startDate && p.endDate) {
                    drawChart(p);
                }
            }
        }

        function toggleTaskCollapse(projectId, phaseId, taskId) {
            const task = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId)?.tasks.find(t => t.id === taskId);
            if (task) {
                task.collapsed = task.collapsed === undefined ? false : !task.collapsed;
                saveProjects();
                document.getElementById(`subtasks-container-${taskId}`).classList.toggle('hidden');
                document.getElementById(`task-chevron-${taskId}`).classList.toggle('-rotate-90');
            }
        }

        function toggleLog(projectId) { document.getElementById(`log-container-${projectId}`).classList.toggle('hidden'); document.getElementById(`log-chevron-${projectId}`).classList.toggle('-rotate-90'); }
        function togglePhaseCollapse(projectId, phaseId) { const phase = projects.find(p => p.id === projectId)?.phases.find(ph => ph.id === phaseId); if (phase) { phase.collapsed = !phase.collapsed; saveProjects(); document.getElementById(`tasks-container-${phaseId}`).classList.toggle('hidden'); document.getElementById(`phase-chevron-${phaseId}`).classList.toggle('-rotate-90'); } }

        function toggleDeletedLog() {
            deletedLogCollapsed = !deletedLogCollapsed;
            renderDeletedProjectsLog();
        }

        function applyTheme() { if (localStorage.getItem('color-theme') === 'dark' || (!('color-theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) { document.documentElement.classList.add('dark'); lightIcon.classList.remove('hidden'); darkIcon.classList.add('hidden'); } else { document.documentElement.classList.remove('dark'); darkIcon.classList.remove('hidden'); lightIcon.classList.add('hidden'); } }
        themeToggleBtn.addEventListener('click', () => { document.documentElement.classList.toggle('dark'); localStorage.setItem('color-theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light'); applyTheme(); renderProjects(); });
        exportBtn.addEventListener('click', () => { const a = document.createElement('a'); a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projects, null, 2)); a.download = "timeline-projects.json"; document.body.appendChild(a); a.click(); a.remove(); });
        importBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const imported = JSON.parse(e.target.result); if (Array.isArray(imported)) { projects = imported; saveProjects(); renderProjects(); } } catch (err) { console.error(err); } }; reader.readAsText(file); e.target.value = null; });
        pdfBtn.addEventListener('click', () => {
            const originalCollapsedState = projects.map(p => ({id: p.id, collapsed: p.collapsed, phases: p.phases.map(ph => ({id: ph.id, collapsed: ph.collapsed}))}));
            projects.forEach(p => { p.collapsed = false; p.phases.forEach(ph => ph.collapsed = false); });
            renderProjects();
            setTimeout(() => {
                window.print();
                projects.forEach(p => {
                    const originalProject = originalCollapsedState.find(op => op.id === p.id);
                    p.collapsed = originalProject.collapsed;
                    p.phases.forEach(ph => {
                        const originalPhase = originalProject.phases.find(oph => oph.id === ph.id);
                        ph.collapsed = originalPhase.collapsed;
                    });
                });
                renderProjects();
            }, 100);
        });

        function initializeSharedDatePicker() {
            const dummy = document.createElement('input'); dummy.style.display = 'none'; document.body.appendChild(dummy);
            sharedPicker = flatpickr(dummy, {
                dateFormat: "Y-m-d", onOpen: () => datepickerBackdrop.classList.remove('hidden'), onClose: () => datepickerBackdrop.classList.add('hidden'),
                onChange: (selectedDates, dateStr, instance) => {
                    if (!currentPickerContext) return;
                    const newDate = instance.formatDate(selectedDates[0], "Y-m-d"), { type, oldDate, element } = currentPickerContext;
                    if (type.startsWith('new-project')) { element.value = formatDate(parseDate(newDate)); element.dataset.date = newDate; instance.close(); return; }
                    if (oldDate && oldDate !== newDate) {
                        pendingDateChange = { context: currentPickerContext, newDate };
                        reasonModalTitle.textContent = 'Reason for Date Change';
                        reasonModalDetails.textContent = `Changing date from ${formatDate(parseDate(oldDate))} to ${formatDate(parseDate(newDate))}.`;
                        reasonModal.classList.remove('hidden');
                        reasonCommentTextarea.focus();
                        instance.close();
                    }
                    else if (!oldDate) { updateDate(currentPickerContext, newDate); instance.close(); } else { instance.close(); }
                },
                onReady: [function() { const button = document.createElement("button"); button.className = "flatpickr-today-button"; button.textContent = "Today"; button.addEventListener("click", (e) => { this.setDate(new Date(), true); e.preventDefault(); }); this.calendarContainer.appendChild(button); }]
            });
            document.body.removeChild(dummy);
        }

        function handleDateTrigger(trigger) {
            if (!trigger) return;
            const { projectId, phaseId, taskId, subtaskId, type } = trigger.dataset;
            currentPickerContext = { type, projectId: parseInt(projectId), phaseId: parseInt(phaseId), taskId: parseInt(taskId), subtaskId: parseInt(subtaskId), element: trigger, oldDate: trigger.dataset.date || null };
            let defaultDate = trigger.dataset.date || new Date();
            if (type && type.endsWith('-end')) {
                let startDate;
                if (subtaskId) startDate = projects.find(p=>p.id===parseInt(projectId))?.phases.find(p=>p.id===parseInt(phaseId))?.tasks.find(t=>t.id===parseInt(taskId))?.subtasks.find(s=>s.id===parseInt(subtaskId))?.startDate;
                else if (taskId) startDate = projects.find(p=>p.id===parseInt(projectId))?.phases.find(p=>p.id===parseInt(phaseId))?.tasks.find(t=>t.id===parseInt(taskId))?.startDate;
                else if (projectId) startDate = projects.find(p=>p.id===parseInt(projectId))?.startDate;
                if (startDate) defaultDate = startDate;
            }
            sharedPicker.set('defaultDate', defaultDate); sharedPicker.open();
        }

        saveReasonBtn.addEventListener('click', () => {
            const comment = reasonCommentTextarea.value.trim();
            if (!comment) {
                reasonCommentTextarea.classList.add('border-red-500', 'ring-red-500');
                setTimeout(() => reasonCommentTextarea.classList.remove('border-red-500', 'ring-red-500'), 2000);
                return;
            }

            if (pendingDateChange) {
                updateDate(pendingDateChange.context, pendingDateChange.newDate, comment);
            } else if (pendingDeletion) {
                const { type, logContext, deleteFn, itemName } = pendingDeletion;

                if (type === 'project') {
                     deletedProjectLogs.push({
                        timestamp: new Date().toISOString(),
                        item: itemName,
                        type: 'deletion',
                        comment: comment
                    });
                } else {
                    const project = projects.find(p => p.id === logContext.projectId);
                    if (project) {
                        if (!project.logs) project.logs = [];
                        project.logs.push({
                            timestamp: new Date().toISOString(),
                            item: itemName,
                            type: 'deletion',
                            comment: comment
                        });
                    }
                }
                
                deleteFn();
                saveProjects();
                renderProjects();
            }

            reasonModal.classList.add('hidden');
            reasonCommentTextarea.value = '';
            pendingDateChange = null;
            pendingDeletion = null;
        });

        cancelReasonBtn.addEventListener('click', () => {
            reasonModal.classList.add('hidden');
            reasonCommentTextarea.value = '';
            renderProjects();
            pendingDateChange = null;
            pendingDeletion = null;
        });

        function handleCircleClick(itemId) {
            const allItems = new Map();
            projects.forEach(p => p.phases.forEach(ph => { allItems.set(ph.id, ph); ph.tasks.forEach(t => { allItems.set(t.id, t); if(t.subtasks) t.subtasks.forEach(st => allItems.set(st.id, st)); }); }));
            const item = allItems.get(itemId);
            if (item.dependencies && item.dependencies.length > 0) {
                pendingClearDependencies = itemId;
                confirmModalText.textContent = 'Do you want to clear the parents for this item?';
                confirmModal.classList.remove('hidden');
            }
        }
        
        cancelConfirmBtn.addEventListener('click', () => {
            confirmModal.classList.add('hidden');
            pendingClearDependencies = null;
        });
        
        confirmActionBtn.addEventListener('click', () => {
            if (pendingClearDependencies) {
                clearDependencies(pendingClearDependencies);
            }
            confirmModal.classList.add('hidden');
            pendingClearDependencies = null;
        });
        
        function clearDependencies(itemId) {
            const allItems = new Map();
            projects.forEach(p => p.phases.forEach(ph => { allItems.set(ph.id, ph); ph.tasks.forEach(t => { allItems.set(t.id, t); if(t.subtasks) t.subtasks.forEach(st => allItems.set(st.id, st)); }); }));
            
            const itemToClear = allItems.get(itemId);
            if (!itemToClear || !itemToClear.dependencies) return;
            
            // Remove this item from its parents' dependents list
            itemToClear.dependencies.forEach(parentId => {
                const parent = allItems.get(parentId);
                if (parent && parent.dependents) {
                    parent.dependents = parent.dependents.filter(id => id !== itemId);
                }
            });
            
            itemToClear.dependencies = [];
            itemToClear.isDriven = false;
            
            saveProjects();
            renderProjects();
        }

        function startDependencyMode(itemId) {
            const allItems = new Map();
            projects.forEach(p => p.phases.forEach(ph => { allItems.set(ph.id, ph); ph.tasks.forEach(t => { allItems.set(t.id, t); if(t.subtasks) t.subtasks.forEach(st => allItems.set(st.id, st)); }); }));
            firstSelectedItem = allItems.get(itemId);
            dependencyMode = true;
            dependencyBanner.classList.remove('hidden');
            renderProjects();
        }
        
        function handleDependencyClick(target) {
             if (!dependencyMode || !firstSelectedItem) return;

            const itemId = parseInt(target.dataset.id);
            if (firstSelectedItem.id === itemId) return;
            const allItems = new Map();
            projects.forEach(p => p.phases.forEach(ph => { allItems.set(ph.id, ph); ph.tasks.forEach(t => { allItems.set(t.id, t); if(t.subtasks) t.subtasks.forEach(st => allItems.set(st.id, st)); }); }));
            const secondItem = allItems.get(itemId); // The new dependent

            // A (first) is the parent, B (second) is the dependent.
            // Check for circular dependency: B cannot be a parent of A.
            let current = secondItem;
            let visited = new Set();
            while(current) {
                if (current.id === firstSelectedItem.id) {
                    alert("Cannot create a circular dependency.");
                    dependencyMode = false;
                    firstSelectedItem = null;
                    dependencyBanner.classList.add('hidden');
                    renderProjects();
                    return;
                }
                if (!current.dependencies || current.dependencies.length === 0 || visited.has(current.id)) break;
                visited.add(current.id);
                current = allItems.get(current.dependencies[0]);
            }

            if (!secondItem.dependencies.includes(firstSelectedItem.id)) {
                secondItem.dependencies.push(firstSelectedItem.id);
            }
            if (!firstSelectedItem.dependents.includes(secondItem.id)) {
                firstSelectedItem.dependents.push(secondItem.id);
            }
            
            dependencyMode = false;
            firstSelectedItem = null;
            dependencyBanner.classList.add('hidden');
            saveProjects();
            renderProjects();
        }

        document.addEventListener('DOMContentLoaded', () => {
            initializeSharedDatePicker();
            document.querySelector('.container').addEventListener('click', (e) => { 
                const icon = e.target.closest('.date-input-icon-wrapper'); 
                if (icon) { 
                    const input = icon.parentElement.querySelector('.date-input'); 
                    if (input && !input.disabled) handleDateTrigger(input);
                    return; // Prevent event from bubbling to dependency handler
                }
                if (dependencyMode) {
                    const candidate = e.target.closest('.dependency-candidate');
                    if (candidate) {
                        handleDependencyClick(candidate);
                    }
                }
            });
            addProjectBtn.addEventListener('click', addProject);
            document.getElementById('toggle-deleted-log-btn').addEventListener('click', toggleDeletedLog);
            closeFullscreenBtn.addEventListener('click', () => {
                fullscreenModal.style.display = 'none';
                d3.select(".chart-tooltip").remove();
            });
            document.addEventListener('keydown', (e) => {
                if(e.key === 'Escape') {
                    if (dependencyMode) {
                        dependencyMode = false;
                        firstSelectedItem = null;
                        dependencyBanner.classList.add('hidden');
                        renderProjects();
                    }
                    if (fullscreenModal.style.display === 'block') {
                         fullscreenModal.style.display = 'none';
                         d3.select(".chart-tooltip").remove();
                    }
                }
            });
            applyTheme();
            loadProjects();
            renderProjects();
        });
    </script>
</body>
</html>
